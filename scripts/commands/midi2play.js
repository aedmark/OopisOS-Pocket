// scripts/commands/midi2play.js

// We need a little help to parse the complex MIDI file format.
// This command will depend on a third-party library.
// The best way to include it is to load it dynamically.
const MIDI_PARSER_URL = 'midi.js';

window.Midi2playCommand = class Midi2playCommand extends Command {
    constructor() {
        super({
            commandName: "midi2play",
            description: "Converts a MIDI file (.mid) into an OopisOS script using the 'play' and 'delay' commands.",
            helpText: `Usage: midi2play <output_script.sh>
      Converts a MIDI file into a playable script.

      DESCRIPTION
      This command will prompt you to upload a MIDI file (.mid) from your local machine.
      It then reads the musical data and translates it into a sequence of 'play' and
      'delay' commands, which it saves to the specified <output_script.sh> file.

      You can then execute the generated script with the 'run' command to hear the music.

      EXAMPLES
      midi2play my_song.sh
      (Upload a MIDI file when prompted)
      run my_song.sh`,
            validations: {
                args: {
                    exact: 1,
                    error: "Usage: midi2play <output_script.sh>"
                }
            },
        });
    }

    async _loadMidiParser() {
        if (window.MidiFile) {
            return true;
        }
        try {
            await new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = MIDI_PARSER_URL;
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
            return true;
        } catch (error) {
            return false;
        }
    }

    _midiNoteToTone(midiNote) {
        const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const octave = Math.floor(midiNote / 12) - 1;
        const noteName = noteNames[midiNote % 12];
        return `${noteName}${octave}`;
    }

    _ticksToToneDuration(ticks, ticksPerBeat) {
        // Based on Tone.js's notation for duration
        const sixteenths = (ticks / ticksPerBeat) * 4;
        if (sixteenths >= 4) {
            return "1m"; // Whole measure
        } else if (sixteenths >= 2) {
            return "2n"; // Half note
        } else if (sixteenths >= 1) {
            return "4n"; // Quarter note
        } else if (sixteenths >= 0.5) {
            return "8n"; // Eighth note
        } else {
            return "16n"; // Sixteenth note
        }
    }

    async coreLogic(context) {
        const { args, currentUser, dependencies } = context;
        const { ErrorHandler, Utils, FileSystemManager, UserManager, OutputManager } = dependencies;
        const outputFilename = args[0];

        // Step 1: Dynamically load the MIDI parser library
        const parserLoaded = await this._loadMidiParser();
        if (!parserLoaded || typeof window.MidiFile === 'undefined') {
            return ErrorHandler.createError("midi2play: Could not load the required MIDI parsing library.");
        }

        // Step 2: Prompt user to upload a file
        const input = Utils.createElement("input", { type: "file", accept: ".mid" });
        document.body.appendChild(input);

        return new Promise((resolve) => {
            input.onchange = async (e) => {
                const file = e.target.files[0];
                document.body.removeChild(input);

                if (!file) {
                    resolve(ErrorHandler.createSuccess("Upload cancelled."));
                    return;
                }

                await OutputManager.appendToOutput(`Processing '${file.name}'...`);

                const reader = new FileReader();
                reader.onload = async (event) => {
                    try {
                        const binaryString = event.target.result;
                        const midi = new window.MidiFile(binaryString);

                        const ticksPerBeat = midi.header.ticksPerBeat || 96;
                        const scriptLines = ["#!/bin/oopis_shell", "# Generated by midi2play"];
                        let lastNoteEndTime = 0;

                        // Consolidate all tracks into a single timeline
                        const allNotes = [];
                        midi.tracks.forEach(track => {
                            let currentTime = 0;
                            track.forEach(event => {
                                currentTime += event.deltaTime;
                                if (event.type === 'channel' && event.subtype === 'noteOn' && event.velocity > 0) {
                                    allNotes.push({
                                        startTime: currentTime,
                                        note: event.noteNumber,
                                        velocity: event.velocity,
                                        duration: 0
                                    });
                                } else if (event.type === 'channel' && (event.subtype === 'noteOff' || (event.subtype === 'noteOn' && event.velocity === 0))) {
                                    const noteOn = allNotes.find(n => n.note === event.noteNumber && n.duration === 0);
                                    if (noteOn) {
                                        noteOn.duration = currentTime - noteOn.startTime;
                                    }
                                }
                            });
                        });

                        // Sort notes by start time
                        allNotes.sort((a, b) => a.startTime - b.startTime);

                        // Generate script
                        for (const note of allNotes) {
                            if (note.duration > 0) {
                                const delayTicks = note.startTime - lastNoteEndTime;
                                if (delayTicks > 0) {
                                    const delayMs = Math.round((delayTicks / ticksPerBeat) * (60000 / (midi.header.bpm || 120)));
                                    if (delayMs > 20) { // Add a small threshold to avoid tiny delays
                                        scriptLines.push(`delay ${delayMs}`);
                                    }
                                }

                                const noteName = this._midiNoteToTone(note.note);
                                const duration = this._ticksToToneDuration(note.duration, ticksPerBeat);
                                scriptLines.push(`play ${noteName} ${duration}`);

                                lastNoteEndTime = note.startTime + note.duration;
                            }
                        }

                        const scriptContent = scriptLines.join('\n');
                        const primaryGroup = UserManager.getPrimaryGroupForUser(currentUser);
                        const absPath = FileSystemManager.getAbsolutePath(outputFilename);
                        const saveResult = await FileSystemManager.createOrUpdateFile(
                            absPath,
                            scriptContent,
                            { currentUser, primaryGroup }
                        );

                        if (saveResult.success) {
                            await FileSystemManager.save();
                            resolve(ErrorHandler.createSuccess(`Successfully converted MIDI to '${outputFilename}'. Run it with 'run ${outputFilename}'!`));
                        } else {
                            resolve(ErrorHandler.createError(`Failed to save script: ${saveResult.error}`));
                        }

                    } catch (err) {
                        resolve(ErrorHandler.createError(`Failed to parse MIDI file: ${err.message}`));
                    }
                };
                reader.readAsBinaryString(file);
            };
            input.click();
        });
    }
};